"use strict";(self.webpackChunkhammeranims=self.webpackChunkhammeranims||[]).push([[5083],{4463:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var r=t(5893),i=t(1151);const a={sidebar_position:2},l="\ud83c\udf10 Level Actions",o={id:"api/hammerlib/advanced/level_actions",title:"\ud83c\udf10 Level Actions",description:"Defering an action to be executed later on the server can be a bit tricky. Let alone making sure it happens even between world reloads, or even game restarts.",source:"@site/docs/api/hammerlib/advanced/level_actions.md",sourceDirName:"api/hammerlib/advanced",slug:"/api/hammerlib/advanced/level_actions",permalink:"/docs/api/hammerlib/advanced/level_actions",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"apiSidebar",previous:{title:"\ud83c\udf33 Zero-code NBT serialization",permalink:"/docs/api/hammerlib/advanced/nbt_serialization"},next:{title:"\ud83d\udc7e Extras",permalink:"/docs/category/-extras"}},s={},c=[{value:"\ud83c\udf4f The simple stuff",id:"-the-simple-stuff",level:2},{value:"\ud83c\udf32 SerializableMethodHandle",id:"-serializablemethodhandle",level:3},{value:"\u2699\ufe0f Example",id:"\ufe0f-example",level:3},{value:"\ud83d\udca5 Custom actions",id:"-custom-actions",level:2},{value:"\u2693 ILevelActionType",id:"-ilevelactiontype",level:3},{value:"\ud83d\uddfa\ufe0f The complete example",id:"\ufe0f-the-complete-example",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"-level-actions",children:"\ud83c\udf10 Level Actions"}),"\n",(0,r.jsx)(n.p,{children:"Defering an action to be executed later on the server can be a bit tricky. Let alone making sure it happens even between world reloads, or even game restarts."}),"\n",(0,r.jsxs)(n.p,{children:["This is where ",(0,r.jsx)(n.code,{children:"LevelAction"}),"s come in."]}),"\n",(0,r.jsxs)(n.p,{children:["The layout is similar to ",(0,r.jsx)(n.code,{children:"IObjectSourceType"})," and ",(0,r.jsx)(n.code,{children:"IObjectSource"})," in a way. We have a type that reads an instance from NBT. This is quite similar here."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"LevelAction"})," itself is an abstract serializable piece of data that doesn't really do anything on its own."]}),"\n",(0,r.jsx)(n.p,{children:"However, HammerLib offers two commonly used implementations to use:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"RunnableLevelAction"})," - Contains a unit of work, represented by abstract method ",(0,r.jsx)(n.code,{children:"run(ServerLevel)"}),", and is executed once.\r\nAn example of such action is ",(0,r.jsx)(n.code,{children:"MethodHandleLevelAction"})," which we'll go over in ",(0,r.jsx)(n.a,{href:"#-the-simple-stuff",children:"\ud83c\udf4f The simple stuff"}),".\r\nAdditionally ",(0,r.jsx)(n.code,{children:"RunnableLevelAction"})," has these utility methods:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"enqueue(ServerLevel)"})," - Submit the instance of ",(0,r.jsx)(n.code,{children:"RunnableLevelAction"})," to ",(0,r.jsx)(n.code,{children:"ServerLevel"})," to be executed on next server tick."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"delay(int)"})," - Create delayed action that will fire this instance's ",(0,r.jsx)(n.code,{children:"run(ServerLevel)"})," code after the given amount of ticks pass."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ContinuousLevelAction"})," - extends ",(0,r.jsx)(n.code,{children:"RunnableLevelAction"})," and provides additional method ",(0,r.jsx)(n.code,{children:"boolean isDone()"}),", letting HammerLib know if the action should continue executing or be marked as complete and discarded.\r\nAn example of continuous action would be ",(0,r.jsx)(n.code,{children:"DelayedLevelAction"})," which keeps on ticking until the delay has passed, and then it executes the child instance once, unless it's also ",(0,r.jsx)(n.code,{children:"ContinuousLevelAction"}),", in which case it would continue executing until the child action is complete."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"-the-simple-stuff",children:"\ud83c\udf4f The simple stuff"}),"\n",(0,r.jsxs)(n.p,{children:["If you don't want to get too into details and are looking for a way to easily call a method with parameters, consider using ",(0,r.jsx)(n.code,{children:"MethodHandleLevelAction"})," which already exists for you."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"MethodHandleLevelAction"})," has a 1-argument constructor, taking in ",(0,r.jsx)(n.code,{children:"SerializableMethodHandle"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"-serializablemethodhandle",children:"\ud83c\udf32 SerializableMethodHandle"}),"\n",(0,r.jsx)(n.p,{children:"Let's say we want to execute a method with given set of data, but we can't really make the lambda persist between world saves. This would bring us to having to create custom actions for every action we want to implement."}),"\n",(0,r.jsx)(n.p,{children:"Instead of doing that, you can create a public static method that takes in a fixed set of data, and performs some sort of work."}),"\n",(0,r.jsx)(n.p,{children:"Let's make an example that will destroy a block as a method handle."}),"\n",(0,r.jsxs)(n.p,{children:["We are going to create a new class (you can reuse any class you want though!) and call it ",(0,r.jsx)(n.code,{children:"BreakBlockHandle"}),", and we're going to put a static method ",(0,r.jsx)(n.code,{children:"breakBlock"})," inside. The method needs a position of a block, a dimension where it happens and a parameter if we want to drop items. Luckily, Minecraft provides ",(0,r.jsx)(n.code,{children:"GlobalPos"})," class, which we're going to reuse here."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import net.minecraft.core.GlobalPos;\r\nimport org.zeith.hammerlib.annotations.ExposedToLevelAction;\r\n\r\npublic class BreakBlockHandle\r\n{\r\n\t@ExposedToLevelAction\r\n\tpublic static void breakBlock(GlobalPos globalPos, boolean dropResources)\r\n\t{\r\n\t}\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The only catch is, this method handle won't really work. To make it work, we have to expose it to level actions. This has to be done explicitly for security reasons we're not going to get into. To expose the method, use ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"@ExposedToLevelAction"})})," (located at ",(0,r.jsx)(n.code,{children:"org.zeith.hammerlib.annotations.ExposedToLevelAction"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"Now let's get a level from the global position in question and actually break a block!"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import net.minecraft.core.GlobalPos;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport org.zeith.hammerlib.annotations.ExposedToLevelAction;\r\nimport org.zeith.hammerlib.util.mcf.LogicalSidePredictor;\r\n\r\npublic class BreakBlockHandle\r\n{\r\n\t@ExposedToLevelAction\r\n\tpublic static void breakBlock(GlobalPos globalPos, boolean dropResources)\r\n\t{\r\n\t\tServerLevel level = LogicalSidePredictor.getLevel(globalPos.dimension());\r\n\t\tif(level == null) return;\r\n\t\t\r\n\t\tlevel.destroyBlock(globalPos.pos(), dropResources);\r\n\t}\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"But wait, you say, how are the GlobalPos and boolean saved between game sessions?"})}),"\n",(0,r.jsxs)(n.p,{children:["The way HammerLib remembers arguments passed through a method handle uses our ",(0,r.jsx)(n.a,{href:"/docs/api/hammerlib/advanced/nbt_serialization",children:"NBTSerializationHelper"}),". Thus, if an argument does not have a serializer, it will not work. Additionally, no instances of ",(0,r.jsx)(n.code,{children:"INBTSerializable<?>"})," may be used unless they explicitly have registered an ",(0,r.jsx)(n.code,{children:"INBTSerializer<?>"})," that can create and deserialize new instances from NBT."]}),"\n",(0,r.jsx)(n.p,{children:"Now that we have our method handle ready and know how it works, let's write an action now!"}),"\n",(0,r.jsx)(n.h3,{id:"\ufe0f-example",children:"\u2699\ufe0f Example"}),"\n",(0,r.jsxs)(n.p,{children:["You can set up a delay to the newly created action using ",(0,r.jsx)(n.code,{children:".delay(N)"}),", where N is number of ticks before the task will get executed."]}),"\n",(0,r.jsxs)(n.p,{children:["HammerLib provides an example method handle for you to test on, it's located inside ",(0,r.jsx)(n.code,{children:"org.zeith.hammerlib.core.test.MethodHandleTest"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public static void enqueueBlockBreak(ServerLevel serverLevel, BlockPos blockPos, int delay, boolean dropResources)\r\n{\r\n\tvar globalPos = GlobalPos.of(serverLevel.dimension(), blockPos.immutable());\r\n\t\r\n\tvar handle = SerializableMethodHandle\r\n                    .create(BreakBlockHandle.class, "breakBlock", null, globalPos, dropResources);\r\n\t\r\n\tnew MethodHandleLevelAction(handle)\r\n\t\t\t.delay(delay)\r\n\t\t\t.enqueue(serverLevel);\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["We're done! Now calling ",(0,r.jsx)(n.code,{children:"enqueueBlockBreak"})," with correct arguments will cause our block to break after a given delay, optionally dropping its items."]}),"\n",(0,r.jsx)(n.h2,{id:"-custom-actions",children:"\ud83d\udca5 Custom actions"}),"\n",(0,r.jsxs)(n.p,{children:["To create a new ",(0,r.jsx)(n.code,{children:"LevelAction"}),", you're going to have to create a new type for it as well."]}),"\n",(0,r.jsx)(n.p,{children:"When creating a new action, you should pick one of the following options:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ContinuousLevelAction"})," ",(0,r.jsx)(n.em,{children:"(extends RunnableLevelAction)"})," for actions that will be called every tick until they are done;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"RunnableLevelAction"})," for any action that will be fired on next server tick, or after a certain period of time;"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"LevelAction"})," a generic level action not doing anything on its own. Might be useful if you can call static ",(0,r.jsx)(n.code,{children:"LevelAction.write"})," and ",(0,r.jsx)(n.code,{children:"LevelAction.read"})," methods to read/write the action whereever you need it."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Let's create a continuous action that will be ran while the world is ticking and spawning particles on player's position until the player dies."}),"\n",(0,r.jsx)(n.p,{children:"First off, let's declare our action class:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"import net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.world.level.Level;\r\nimport org.zeith.hammerlib.abstractions.actions.*;\r\n\r\npublic class ParticleAction\r\n\t\textends ContinuousLevelAction\r\n{\r\n\tpublic ParticleAction(ILevelActionType type)\r\n\t{\r\n\t\tsuper(type);\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean isDone()\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic void run(ServerLevel level)\r\n\t{\r\n\t\t\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic CompoundTag write(Level level)\r\n\t{\r\n\t\tCompoundTag nbt = new CompoundTag();\r\n\t\t\r\n\t\treturn nbt;\r\n\t}\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now let's add our player information in here..."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class ParticleAction\r\n\t\textends ContinuousLevelAction\r\n{\r\n\tprotected final UUID playerId;\r\n\t\r\n\tpublic ParticleAction(ILevelActionType type, UUID playerId)\r\n\t{\r\n\t\tsuper(type);\r\n\t\tthis.playerId = playerId;\r\n\t}\r\n    ...\n"})}),"\n",(0,r.jsx)(n.p,{children:"Write a method to get ServerPlayer from ServerLevel..."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Nullable // <- This is here just to make it obvious that the player may not be online.\r\nprotected ServerPlayer getPlayer(ServerLevel level)\r\n{\r\n\treturn level.getServer().getPlayerList().getPlayer(playerId);\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Afterwards, we need to add a way to stop the action at some point..."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class ParticleAction\r\n\t\textends ContinuousLevelAction\r\n{\r\n\tprotected final UUID playerId;\r\n\tprotected boolean isPlayerDead;\r\n\r\n    ...\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"...\r\n\r\n@Override\r\npublic boolean isDone()\r\n{\r\n\treturn isPlayerDead;\r\n}\r\n\r\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now the particle spawning part and completing the task if player dies:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Override\r\npublic void run(ServerLevel level)\r\n{\r\n\tvar player = getPlayer(level);\r\n\tif(player == null) return;\r\n\t\r\n\tif(player.isDeadOrDying())\r\n\t{\r\n\t\tisPlayerDead = true;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tvar rng = player.getRandom();\r\n\tvar pos = player.position();\r\n\t\r\n\tfloat xSpread = 0.3F;\r\n\tfloat ySpread = 0.125F;\r\n\tfloat zSpread = 0.3F;\r\n\tint particleCount = rng.nextInt(1, 3);\r\n\tfloat speed = rng.nextFloat() * 0.01F + 0.005F;\r\n\t\r\n\tlevel.sendParticles(ParticleTypes.FLAME, pos.x, pos.y + 0.125F, pos.z, particleCount, xSpread, ySpread, zSpread, speed);\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Finally, we need NBT writing code..."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@Override\r\npublic CompoundTag write(Level level)\r\n{\r\n\tCompoundTag nbt = new CompoundTag();\r\n\tnbt.putUUID("Player", playerId);\r\n\tnbt.putBoolean("IsDead", isPlayerDead);\r\n\treturn nbt;\r\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"-ilevelactiontype",children:"\u2693 ILevelActionType"}),"\n",(0,r.jsx)(n.p,{children:"Action types are factories for creating (reading) action instances from NBT into runtime."}),"\n",(0,r.jsx)(n.p,{children:"Let's continue our example above and write a type for it!"}),"\n",(0,r.jsxs)(n.p,{children:["First off we need a custom constructor for ",(0,r.jsx)(n.code,{children:"ParticleAction"})," to read from NBT:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public ParticleAction(ILevelActionType type, Level level, CompoundTag tag)\r\n{\r\n\tthis(type, tag.getUUID("Player"));\r\n\tthis.isPlayerDead = tag.getBoolean("IsDead");\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"After that specific constructor is complete, we may now create a new action type:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"ILevelActionType CONTINUOUS_PARTICLES = ILevelActionType.simple(ParticleAction::new);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["And obviously it must be registered, I recommend using ",(0,r.jsx)(n.a,{href:"/docs/api/hammerlib/basics/content_registration",children:"@SimplyRegister"})," and creating a new interface ",(0,r.jsx)(n.code,{children:"ModLevelActionTypes"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.world.level.Level;\r\nimport org.zeith.hammerlib.abstractions.actions.*;\r\nimport org.zeith.hammerlib.annotations.*;\r\n\r\n@SimplyRegister\r\npublic interface ModLevelActionTypes\r\n{\r\n\t@RegistryName("continuous_particles")\r\n\tILevelActionType CONTINUOUS_PARTICLES = ILevelActionType.simple(ParticleAction::new);\r\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"\ufe0f-the-complete-example",children:"\ud83d\uddfa\ufe0f The complete example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import net.minecraft.core.particles.ParticleTypes;\r\nimport net.minecraft.nbt.CompoundTag;\r\nimport net.minecraft.server.level.ServerLevel;\r\nimport net.minecraft.server.level.ServerPlayer;\r\nimport net.minecraft.world.entity.player.Player;\r\nimport net.minecraft.world.level.Level;\r\nimport org.jetbrains.annotations.Nullable;\r\nimport org.zeith.hammerlib.abstractions.actions.ContinuousLevelAction;\r\nimport org.zeith.hammerlib.abstractions.actions.ILevelActionType;\r\n\r\nimport java.util.UUID;\r\n\r\npublic class ParticleAction\r\n\t\textends ContinuousLevelAction\r\n{\r\n\tprotected final UUID playerId;\r\n\tprotected boolean isPlayerDead;\r\n\t\r\n\tpublic ParticleAction(Player player)\r\n\t{\r\n\t\tthis(ModLevelActionTypes.CONTINUOUS_PARTICLES, player.getGameProfile().getId());\r\n\t}\r\n\t\r\n\tpublic ParticleAction(ILevelActionType type, UUID playerId)\r\n\t{\r\n\t\tsuper(type);\r\n\t\tthis.playerId = playerId;\r\n\t}\r\n\t\r\n\tpublic ParticleAction(ILevelActionType type, Level level, CompoundTag tag)\r\n\t{\r\n\t\tthis(type, tag.getUUID("Player"));\r\n\t\tthis.isPlayerDead = tag.getBoolean("IsDead");\r\n\t}\r\n\t\r\n\t@Nullable // <- This is here just to make it obvious that the player may not be online.\r\n\tprotected ServerPlayer getPlayer(ServerLevel level)\r\n\t{\r\n\t\treturn level.getServer().getPlayerList().getPlayer(playerId);\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean isDone()\r\n\t{\r\n\t\treturn isPlayerDead;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic void run(ServerLevel level)\r\n\t{\r\n\t\tvar player = getPlayer(level);\r\n\t\tif(player == null) return;\r\n\t\t\r\n\t\tif(player.isDeadOrDying())\r\n\t\t{\r\n\t\t\tisPlayerDead = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tvar rng = player.getRandom();\r\n\t\tvar pos = player.position();\r\n\t\t\r\n\t\tfloat xSpread = 0.3F;\r\n\t\tfloat ySpread = 0.125F;\r\n\t\tfloat zSpread = 0.3F;\r\n\t\tint particleCount = rng.nextInt(1, 3);\r\n\t\tfloat speed = rng.nextFloat() * 0.01F + 0.005F;\r\n\t\t\r\n\t\tlevel.sendParticles(ParticleTypes.FLAME, pos.x, pos.y + 0.125F, pos.z, particleCount, xSpread, ySpread, zSpread, speed);\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic CompoundTag write(Level level)\r\n\t{\r\n\t\tCompoundTag nbt = new CompoundTag();\r\n\t\tnbt.putUUID("Player", playerId);\r\n\t\tnbt.putBoolean("IsDead", isPlayerDead);\r\n\t\treturn nbt;\r\n\t}\r\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import org.zeith.hammerlib.abstractions.actions.ILevelActionType;\r\nimport org.zeith.hammerlib.annotations.RegistryName;\r\nimport org.zeith.hammerlib.annotations.SimplyRegister;\r\n\r\n@SimplyRegister\r\npublic interface ModLevelActionTypes\r\n{\r\n\t@RegistryName("continuous_particles")\r\n\tILevelActionType CONTINUOUS_PARTICLES = ILevelActionType.simple(ParticleAction::new);\r\n}\n'})})]})}function p(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>l});var r=t(7294);const i={},a=r.createContext(i);function l(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);