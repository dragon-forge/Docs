"use strict";(self.webpackChunkhammeranims=self.webpackChunkhammeranims||[]).push([[7617],{54:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var i=n(5893),a=n(1151);const r={sidebar_position:0},o="\ud83d\udca1 Multipart Concept",s={id:"api/hammermultipart/basics/parts",title:"\ud83d\udca1 Multipart Concept",description:"So how does everything fit together?",source:"@site/docs/api/hammermultipart/basics/parts.md",sourceDirName:"api/hammermultipart/basics",slug:"/api/hammermultipart/basics/parts",permalink:"/docs/api/hammermultipart/basics/parts",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0},sidebar:"apiSidebar",previous:{title:"\ud83d\udce6 Essential Knowledge",permalink:"/docs/category/-essential-knowledge"},next:{title:"\u2728 Creating a Multipart",permalink:"/docs/api/hammermultipart/basics/part_creation"}},l={},c=[{value:"\ud83d\udcac The Concept",id:"-the-concept",level:2},{value:"\ud83d\udd35 Parts at Core",id:"-parts-at-core",level:2},{value:"\ud83e\udeaa PartDefinition",id:"-partdefinition",level:3},{value:"\ud83d\udc27 PartEntity",id:"-partentity",level:3},{value:"\u2699\ufe0f Placement Logic",id:"\ufe0f-placement-logic",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"-multipart-concept",children:"\ud83d\udca1 Multipart Concept"}),"\n",(0,i.jsx)(t.p,{children:"So how does everything fit together?"}),"\n",(0,i.jsx)(t.h2,{id:"-the-concept",children:"\ud83d\udcac The Concept"}),"\n",(0,i.jsx)(t.p,{children:"In its base, to make parts fit into a single block, a container block is required."}),"\n",(0,i.jsx)(t.p,{children:"This is exactly what HammerMultipart provides, alongside some APIs to make things work."}),"\n",(0,i.jsxs)(t.p,{children:["Such containers may be referenced through ",(0,i.jsx)(t.code,{children:"WorldPartComponents.getContainer(BlockGetter get, BlockPos pos)"}),".\r\nEvery container has internal storage for all placed parts, with their placement as a key."]}),"\n",(0,i.jsx)(t.p,{children:"When more parts are placed into a container, it checks  if a part can be placed into its selected spot by a given complex set of rules."}),"\n",(0,i.jsxs)(t.p,{children:["Each part inside a container is considered a ",(0,i.jsx)(t.code,{children:"PartEntity"}),", constructed from ",(0,i.jsx)(t.code,{children:"PartDefinition"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"-parts-at-core",children:"\ud83d\udd35 Parts at Core"}),"\n",(0,i.jsxs)(t.p,{children:["Similar to how you have ",(0,i.jsx)(t.code,{children:"BlockEntityType<T>"})," that create ",(0,i.jsx)(t.code,{children:"BlockEntity"})," instances, we have ",(0,i.jsx)(t.code,{children:"PartDefinition"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Although it would be more fair to compare ",(0,i.jsx)(t.code,{children:"PartDefinition"})," to vanilla ",(0,i.jsx)(t.code,{children:"Block"})," as it shares some properties with the block type."]}),"\n",(0,i.jsx)(t.h3,{id:"-partdefinition",children:"\ud83e\udeaa PartDefinition"}),"\n",(0,i.jsx)(t.p,{children:"The most important attributes for said definitions are:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"soundType"}),", and is accessed by ",(0,i.jsx)(t.code,{children:"PartDefinition.getSoundType(PartEntity entity)"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"survivesInWater"}),", and is accessed by ",(0,i.jsx)(t.code,{children:"PartDefinition.canSurviveInWater(PartEntity entity)"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"model"})," - this field is responsible for storing all model visual properties like its particle sprite(s) and sub-models that must be loaded in."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"tintIndexCount"})," - the amount of tint indices used up by this part. Useful for things like wires that may need to be tinted according to their redstone signal strength. ",(0,i.jsx)(t.a,{href:"/docs/api/hammermultipart/advanced/tint",children:"This is explained in a separate page"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"cloneItem"})," - provides the ",(0,i.jsx)(t.code,{children:"ItemStack"})," which is going to get cloned whenever player performs middle-click while having the part selected."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["If your part is a wrapper for an existing block, take a look into ",(0,i.jsx)(t.code,{children:"Optional<PlacedPartConfiguration> convertBlockToPart(Level level, BlockPos pos, BlockState state)"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["This method is used to convert a block on a given position into a part. ",(0,i.jsx)(t.code,{children:"PlacedPartConfiguration"})," is a record containing the ",(0,i.jsx)(t.code,{children:"PartDefinition"}),", ",(0,i.jsx)(t.code,{children:"PartPlacement"})," and ",(0,i.jsx)(t.code,{children:"IConfiguredPartPlacer"})," (which creates ",(0,i.jsx)(t.code,{children:"PartEntity"})," if the placement will go through)."]}),"\n",(0,i.jsxs)(t.li,{children:["Take a look at how HammerMultipart implements this method in torches (see ",(0,i.jsx)(t.a,{href:"https://github.com/dragon-forge/HammerMultipart/blob/1.20.1/src/main/java/org/zeith/multipart/impl/parts/PartDefTorch.java",children:"PartDefTorch"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Each PartDefinition must also implement ",(0,i.jsx)(t.code,{children:"PartEntity createEntity(PartContainer container, PartPlacement placement)"})," method, which is going to create new instances of a ",(0,i.jsx)(t.code,{children:"PartEntity"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"-partentity",children:"\ud83d\udc27 PartEntity"}),"\n",(0,i.jsx)(t.p,{children:'These "entities" are responsible for storing part\'s data, as well as providing all functionality.'}),"\n",(0,i.jsx)(t.p,{children:"There are a ton of methods, which we're going to explore here, although here are the most important ones that you should definitely take a look at:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"updateShape()"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Called periodically to refresh the shape of a part. Useful when dealing with complex shapes like pipes which should change their shape based on connected neighbors."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"getDrops(@Nullable ServerPlayer harvester, LootParams.Builder context)"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Called when this part is broken and its drops are being collected. You should add your part placing item if you have one here."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"neighborChanged(@Nullable Direction from, BlockPos neigborPos, BlockState neigborState, boolean waterlogged)"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Similar to Vanilla's code, invoked from the Block's ",(0,i.jsx)(t.code,{children:"neighborChanged"}),", ",(0,i.jsx)(t.code,{children:"placeLiquid"})," and ",(0,i.jsx)(t.code,{children:"updateShape"})," methods."]}),"\n",(0,i.jsxs)(t.li,{children:["Use to queue the part removal if your part can no longer exist under given conditions. (Call ",(0,i.jsx)(t.code,{children:"container.queuePartRemoval(placement, spawnDrops, playSound, spawnParticles);"})," method)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"tickShared()"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Called each game tick to update the part's logic. It's being called from the part container ",(0,i.jsx)(t.code,{children:"BlockEntity"})," tick method."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"getRenderModels()"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["You should add all models that should be rendered onto the part mesh. Each ",(0,i.jsx)(t.code,{children:"ResourceLocation"}),' would be in a format of "yourmod',":part",'/mypart"']}),"\n",(0,i.jsxs)(t.li,{children:["These must be also added into the definition using ",(0,i.jsx)(t.code,{children:"PartDefinition.model.addSubmodel()"})," unless you are referencing item/block models that are already registered by vanilla (or other mods)"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Optional<Tuple2<BlockState, Function<BlockPos, BlockEntity>>> disassemblePart()"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Called as soon as there is just one part left, attempting to convert it back to the block it may may have been."}),"\n",(0,i.jsx)(t.li,{children:"Used by vanilla parts (ladders, chains, torches) to turn into vanilla blocks instead of using up server resources for no reason."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"\ufe0f-placement-logic",children:"\u2699\ufe0f Placement Logic"}),"\n",(0,i.jsx)(t.p,{children:"To prevent multiple parts colliding inside a container and/or conflicting with one another, there exist a few mandatory checks before more parts would be placed:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"PartPlacement.canBePlacedAlongside(Set<PartPlacement> others)"})," check on the placement a part will occupy;"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"PartDefinition.canPlaceAt(PartContainer container, @Nullable IConfiguredPartPlacer placer, PartPlacement placement)"})," will call to the context part which is being placed;"]}),"\n",(0,i.jsxs)(t.li,{children:["Each taken ",(0,i.jsx)(t.code,{children:"PartPlacement"})," will be asked by calling ",(0,i.jsx)(t.code,{children:"isCompatibleWith(PartPlacement other)"}),', the argument "other" being the context part placement;']}),"\n",(0,i.jsxs)(t.li,{children:["Each placed ",(0,i.jsx)(t.code,{children:"PartEntity"})," may block the placement based on the return value of ",(0,i.jsx)(t.code,{children:"blocksPlacementFor(PartDefinition definition, PartPlacement definitionPosition)"}),";"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"After these steps are taken into consideration, an optional merge step is attempted:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["If the context ",(0,i.jsx)(t.code,{children:"PartPlacement"})," is occupied, the context ",(0,i.jsx)(t.code,{children:"PartDefinition"})," will run ",(0,i.jsx)(t.code,{children:"tryMergeWith(PartContainer container, PartPlacement placement, PartEntity otherEntity)"}),"\r\nIf the merge fails, so does the placement."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["After all this, the ",(0,i.jsx)(t.code,{children:"PartEntity.getPartOccupiedShape()"})," is called to check the context ",(0,i.jsx)(t.code,{children:"PartEntity"})," against all other parts. Their shape (for this specific call) is obtained via ",(0,i.jsx)(t.code,{children:"PartEntity.getPartOccupiedShapeWith(PartEntity toBePlaced, VoxelShape shapeOfEntity)"})," which gives mod dev an option to shrink the shape down for things like wires while keeping them connected visually."]}),"\n",(0,i.jsx)(t.p,{children:"If no shape intersections would be found, the placement succeeds, and the part places into the container, causing a sync packet to be dispatched to tracking players."})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>s,a:()=>o});var i=n(7294);const a={},r=i.createContext(a);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);